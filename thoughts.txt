==============================================================================================
TODO:
    + Classes need a cycle check to ensure they aren't a sub/super-class of themselves.

    + VM "stacks" are fixed size with magic numbers, these probably should be allocated up
    front by a variable/command line argument. Alternatively since these are entirely accessed
    using indexes they could even be dynamically allocated.

    + Implement VM calls (see: VM Calling Convention)

    + Implement the AST to IR visitor

    + Implement Object + Type system

    + Write tests for every VM instruction

    + Write tests for every Codegen function

    + AST should begin generating type declarations and the IR should handle actually
    defining them
        x: MyObj = new... implicitly declares/references the `MyObj' type
        x := new Thing    implicitly declares/references the `Thing' type
        struct MyStruct   will ensure MyStruct hasn't been declared, and then it will declare
                          MyStruct
        y :: fn(a:int, b:string) -> void {}   references types: `int', `string' and `void' 
                          and implicitly declares/references the type: `(int,string) -> void'


==============================================================================================
VM Calling Convention:

    Arguments:
    + VM call arguments use data stack; when a call happens save the current data stack top 
    and use that to access arguments:
      - fn (a, b, c, d, e)
      - Load/Store_Arg_0 = e, 1 = d, 2 = c, 3 = b, N[4] = a this will work because the body 
      will know where each argument is as soon as the function is declared.
      - variadic arguments can be handled by the compiler generating an array of values and
      then pushing that to the data stack last, the array would be accessible with Load_Arg_0

    + The backwards accessibility ordering looks odd but it allows for arguments to be
    evaluated in order from left to right without having to rearrange their ordering on the
    stack before the call is executed.

    Return values:
    + Since the data stack is also used to "return" values from functions, it is the caller's
    responsibility to unpack or drop them as necessary. This allows functions to return any
    number of values.

    Local variables:
    + Local variables use a separate `locals' stack and allocating/freeing space on this stack
    is controlled by the callee itself.

    Instance Method calls:
    + The object instance, "this", is implicitly passed to a method call last. Doing this
    allows "this" to always be accessible with Load/Store_Arg_0. This also makes chaining
    method calls more fluid because it is a simple Load_Arg_0 before calling a method within
    another method.

==============================================================================================
Object Representation:
    color:
        0 = white: it's not reachable
        1 = grey:  it's reachable
        2 = black: we've marked all sub-references grey
    struct Object
    {
        Type_Info *type_info;
        unsigned char free : 1;
        unsigned char color : 2;
        Value *fields;

        void gc_mark(); // visits every field, if it's an object call its gc_mark
    };

==============================================================================================
Garbage Collection:
    visit everything:
        VM::globals
        VM::locals
        VM::data_stack

        0. if it's not a pointer, skip
        1. if it's already black, skip
        2. mark object grey
        3. for each object this object references go to 2
        4. mark this object black
        5. visit all objects in the global object store
        6. if it's black, mark it white for the next run, and skip
        7. if it's grey, throw an error, there should be no grey objects while freeing
        8. if it's white, mark it as free

==============================================================================================
IR:
    Symbol table to map symbols to globals/locals/fields
    Label table to backfill branches


    Builtin primitives:
        Boolean
        Char
        Fixnum
        Single
        Double
        Array
        String
        Callable

    Symbol
    Call
    Call method
    Return
    Label
    Named block
    Branch
    Branch if true
    Branch if false
    Assignment
    Binary operators:
        + - * / % & | ^
        << >> < > <= >=
        ==

    Unary operators:
        ! ~ - +

    Type
    Allocate object
    Deallocate object


==============================================================================================
Logical Conditions with Short-Circuiting:
    Note:
      These all end with a jump_if_false(alternative) because if we get that far and fail
      then the condition was not met.

    `if (x || y) { A: ... } B:`
    Represented as:
    do_x                              ; pushes a bool to stack
    jump_if_true(A)                   ; pop 1, jump if true
    do_y                              ; pushes a bool to stack
    jump_if_false(B)                  ; pop 1, jump if false
    A:
        ...
    B:
        ...

    `if (x && y) { A: ... } B:`
    Represented as:
    do_x                              ; pushes a bool to stack
    jump_if_false(B)                  ; pop 1, jump if false
    do_y                              ; pushes a bool to stack
    jump_if_false(B)                  ; pop 1, jump if false
    A:
        ...
    B:
        ...

==============================================================================================
DONE:

Oct 12, 2017:
    + Figure out how to store floats/doubles
      ? no primitive floating point types, box them all?
      ? tagged pointers, integers go to 31 or 63 bits, some overhead
      ? maybe this is solvable with locals reordering or some analysis at compile time
    + Implemented a Value system using boxed nans, abusing 48 bit pointers and 32 bit fixnums

Oct 13, 2017:
    + Implemented basic tri-color GC, it needs to link better with the VM.
      * GC needs lots of testing
      * in the future, the GC could benefit from generations.
      * currently, it only looks at how many objects are allocated and not how much space
        an object occupies

    + Implemented some of the necessary base IR nodes

Oct 14, 2017:
    + Implement the IR tree structs
    + First source to bytecode translation!
    + Partial implementation of AST to IR converter
    + Partial implementation of IR to bytecode converter

Oct 15, 2017:
    + Documented the VM's instruction set
    + Implemented some VM instructions
    + Fixed some VM instructions
    + Partial implementation of LValue/RValue concepts to make AST to IR translation easier

Oct 16, 2017:
    + Added source locations to AST nodes
    + Bringing the Type_Map towards being useful during source parsing and IR translation

Oct 17, 2017:
    + Implemented better VM helper functions
    + Implemented argument access in the VM
    + Implemented class definition parsing
    + Implemented declaration+assign parsing
    + Implemented declaration+constant parsing
    + Implemented type parsing

Oct 18, 2017:
    + Implemented some primitives methods for fixnum and double operators
    + Implemented a new VM instruction called Call_Primitive
    + Most(all?) IR expressions are now IR_Values and contain type information.

Oct 19, 2017:
    + Turned IR Binary operators into deducible method calls
    + Can now compile multi-expression expressions into VM code
    + Cleaned up some of the VM runtime stuff
    + Factored out some code repetition
    + Implemented more instructions in the Codegen
    + Implemented very basic symbols e.g:
      x := 10;
      y := 11;
      z := 2 * (x + y);
      z; // leaves 42 at the top of the stack

Oct 20, 2017:
    --

Oct 21, 2017:
    + Better disassembly output
    + Fixed bug in branch codegen
    + Basic function code generator
    + Basic call generation
    + IR_Labels have the ability to backfill their addresses after calculation

Oct 22, 2017:
    + Hackery to call builtin free functions
    + New VM instruction: Call_Dyn
    + New VM instruction: Call_Primitive_Dyn
    
